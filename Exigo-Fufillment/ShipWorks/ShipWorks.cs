using System;
using System.Configuration;
using System.Xml.Linq;
using System.Collections.Generic;
using System.Xml.Serialization;
using System.Linq;
using System.Xml.Schema;
using System.IO;
using System.Xml;
using ExigoShipWorks.exigo.api;
using System.Runtime.Serialization;
using System.Security.Cryptography;
using Dapper;
using System.Data.SqlClient;

namespace shipworks
{
    public partial class ShipWorks
    {

        /// <summary>
        /// This class extends the class that is autogenerated by the shipworks XSD
        ///
        /// Note: Debugging in the class will not work if the partial class is regenerated and the [System.Diagnostics.DebuggerStepThroughAttribute()] exists.
        /// 
        /// </summary>

        //This class will be serialized into the XML response.

        //All methods in the class update the "item" object which is serailzed into the message back to ShipWorks per their XSD


        //We will be doing a lot of datetime conversions since exigo data is in central time so lets get this ready
        private TimeZoneInfo centralTimeZone = TimeZoneInfo.FindSystemTimeZoneById("Central Standard Time");
        private string companyKey;
        private string sandboxEnv = "";
        private SqlConnection reportingDb;
        private string user;
        private string pass;
        private ExigoApi api;

        public ShipWorks() { }
        public ShipWorks(string companykey, string sandbox, string username, string password)
        {
            schemaVersion = "1.1.0";
            moduleVersion = "3.10.0";
            companyKey = companykey;
            sandboxEnv = sandbox ?? "";
            user = username;
            pass = password;

            if (sandboxEnv != "")
            {
                reportingDb = new SqlConnection("server=" + sandboxEnv + "." + companykey + ".bi.exigo.com;database=" + companyKey + "Reporting" + sandboxEnv + ";uid=" + user + ";pwd=" + pass + ";");
            }
            else
            {
                reportingDb = new SqlConnection("server=" + companykey + ".bi.exigo.com;database=" + companyKey + "Reporting;uid=" + user + ";pwd=" + pass + ";");
            }

            api = new ExigoApi();
            var auth = new ApiAuthentication();
            auth.LoginName = user;
            auth.Password = pass;
            auth.Company = companyKey;
            api.ApiAuthenticationValue = auth;
            if (sandboxEnv == "")
            {
                api.Url = "https://api.exigo.com/3.0/ExigoApi.asmx";
            }
            else
            {
                api.Url = "http://sandboxapi" + sandboxEnv.ToLowerInvariant().Replace("sandbox", "").ToString() + ".exigo.com/3.0/ExigoApi.asmx";
            }

        }
        public bool Auth()
        {
            bool check = false;
            try
            {
                using (var context = reportingDb)
                {
                    check = context.Query<bool>(@"SELECT 1").FirstOrDefault();
                }
            }
            catch { }
            return check;
        }
        public XDocument GetStatusCodesResponse()
        {
            List<StatusCode> statusCodes = new List<StatusCode>();

            // TODO we might not want to show all statuses, they will only ever see status printed and shipped.
            // Loop through all the statustypes in the API definition and add to the XML doc

            #region All Status Codes 
            //foreach (OrderStatusType status in Enum.GetValues(typeof(OrderStatusType)))
            //{

            //    var statusCode = new StatusCode
            //    {
            //        Code = status.ToString(),
            //        Name = status.ToString()
            //    };

            //    statusCodes.Add(statusCode);
            //}
            #endregion

            //Only going to show printed and shipped statuses and let shipworks updaste to these.
            statusCodes.Add(new StatusCode { Code = "Accepted", Name = "Accepted" });
            statusCodes.Add(new StatusCode { Code = "Printed", Name = "Printed" });
            statusCodes.Add(new StatusCode { Code = "Shipped", Name = "Shipped" });

            //Populate the item object with the data
            Item = new ShipWorksStatusCodes() { StatusCode = statusCodes.ToArray() };
            return ToXDoc();
        }
        public XDocument GetModuleResponse()
        {
            var module = new Module()
            {
                Platform = "Exigo",
                Developer = "Exigo Office Inc.",
                Capabilities = new ModuleCapabilities()
                {
                    DownloadStrategy = ModuleCapabilitiesDownloadStrategy.ByModifiedTime,
                    OnlineCustomerID = new ModuleCapabilitiesOnlineCustomerID()
                    {
                        dataType = VariantDataType.numeric,
                        dataTypeSpecified = true,
                        supported = true
                    },
                    OnlineStatus = new ModuleCapabilitiesOnlineStatus()
                    {
                        dataType = VariantDataType.text,
                        dataTypeSpecified = true,
                        supported = true,
                        supportsComments = false,
                        downloadOnly = false,
                        downloadOnlySpecified = true
                    },
                    OnlineShipmentUpdate = new ModuleCapabilitiesOnlineShipmentUpdate()
                    {
                        supported = true
                    }
                }
            };

            Item = module;
            return ToXDoc();
        }
        public XDocument GetStoreResponse()
        {
            var store = new Store()
            {
                Name = "Exigo",
                CompanyOrOwner = companyKey
            };

            Item = store;
            return ToXDoc();
        }
        private XDocument ToXDoc()
        {
            XmlSerializer xmlSerializer = new XmlSerializer(this.GetType());

            XDocument doc = new XDocument();
            using (var writer = doc.CreateWriter())
            {
                xmlSerializer.Serialize(writer, this);
            }

            XmlSchemaSet schema = new XmlSchemaSet();
            var fileStream = new StreamReader(System.IO.Path.Combine(System.AppDomain.CurrentDomain.BaseDirectory, "bin\\ShipWorks\\") + "ShipWorks1_1_0.xsd");
            schema.Add("", XmlReader.Create(new StringReader(fileStream.ReadToEnd())));

            doc.Validate(schema, (o, e) =>
            {
                throw new Exception(e.Message);
            });

            return doc;
        }

        #region Reporting Database
        public XDocument GetCountResponseFromReportingDb(DateTime greaterThanModifiedDate)
        {

            DateTime startDateTime = TimeZoneInfo.ConvertTimeFromUtc(greaterThanModifiedDate, centralTimeZone);

            //shipworks will start at 0 BC which sql doesn't like... so we will catch this and set it to 1/1/1900
            var earliest = new DateTime(1900, 1, 1, 0, 0, 0);
            DateTime sqlStartTime;
            if (DateTime.Compare(startDateTime, earliest) > 0)
            {
                sqlStartTime = startDateTime;
            }
            else
            {
                sqlStartTime = earliest;
            }

            //NOTE Removed Payment from this query since the shipworks object doesn't have a unique payment identifier and it will take a bit longer to do it properly.

            var query = @"
            SELECT 
	            COUNT(OrderID)
            FROM orders 
		    WHERE cast(modifieddate as smalldatetime) >= @LastModified
                AND OrderStatusID = 7
                AND OrderTypeId <> 8";

            int count;
            using (var context = reportingDb)
            {
                count = context.Query<int>(query,
                    param: new { LastModified = sqlStartTime }).FirstOrDefault();
            }

            //Update the response variable
            Item = count;
            return ToXDoc();
        }
        public XDocument GetOrdersResponseFromReportingDb(DateTime greaterThanModifiedDate, int maxCount)
        {

            //TODO Probably need to add a delay so that an order doesn't get shipped immediatly after it's posted... best practice is to leave at least an hour?

            DateTime startDateTime = TimeZoneInfo.ConvertTimeFromUtc(greaterThanModifiedDate, centralTimeZone);

            //shipworks will start at 0 BC which sql doesn't like... so we will catch this and set it to 1/1/1900
            var earliest = new DateTime(1900, 1, 1, 0, 0, 0);
            DateTime sqlStartTime;
            if (DateTime.Compare(startDateTime, earliest) > 0)
            {
                sqlStartTime = startDateTime;
            }
            else
            {
                sqlStartTime = earliest;
            }

            //NOTE Removed Payment from this query since the shipworks object doesn't have a unique payment identifier and it will take a bit longer to do it properly.

            var query = @"
            SELECT 
	            OrderNumber = orders.orderid, 
	            OrderDate = orders.orderdate,--Convert this to UTC in code 
	            LastModified = orders.modifieddate,--Convert this to UTC in code 
	            -- Last Modified wasn't showing up in the XML Serializer... not sure why, this isn't listed in their documentation but it works now...
	            LastModifiedSpecified = 1, 
	            ShippingMethod = shipmethods.shipmethoddescription, 
	            StatusCode = orderstatuses.orderstatusdescription, 
	            CustomerID = orders.customerid, 
	            Subtotal = orders.Subtotal,
	            Shipping = orders.Shippingtotal,
	            Total = orders.Total,
	            --Shipping and Billing Address 
	            FullName = orders.firstname + ' ' + orders.lastname, 
	            Company = orders.company, 
	            Street1 = orders.address1, 
	            Street2 = orders.address2, 
	            Street3 = orders.address3, 
	            City = orders.city, 
	            State = orders.state, 
	            PostalCode = orders.zip, 
	            Country = orders.country, 
	            Phone = orders.phone, 
	            Email = orders.email, 
	            --Items 
	            ItemID = orderdetails.orderline, 
	            -- TODO Check what ItemID means in ShipWorks 
	            ProductID = orderdetails.itemcode, 
	            Code = orderdetails.itemcode, 
	            NAME = orderdetails.itemdescription, 
	            Quantity = orderdetails.quantity, 
	            UnitPrice = orderdetails.priceeach, 
	            Weight = orderdetails.weight 
            FROM   orders 
                JOIN ( --order filter
		            SELECT TOP " + maxCount + @"+ orderid 
		            FROM orders 
		            WHERE cast(modifieddate as smalldatetime) >= @LastModified
                        AND OrderStatusID = 7
                        AND OrderTypeId <> 8
		            ORDER  BY modifieddate ASC) f 
			            ON orders.orderid = f.orderid
	            JOIN orderstatuses 
                        ON orderstatuses.orderstatusid = orders.orderstatusid 
                JOIN shipmethods 
                        ON orders.shipmethodid = shipmethods.shipmethodid 
                JOIN orderdetails 
                        ON orders.orderid = orderdetails.orderid";

            //lookup lists for keeping things straight when serializing the result set to shipworks objects

            var orderLookup = new Dictionary<long, Order>();
            var itemLookup = new Dictionary<long, Dictionary<string, Item>>();

            //Skipping payments for now, since the shipworks payment objects don't have a unique identifier we would have to build an object to keep track of these with the paymentid to prevent duplicates (More work)...

            using (var context = reportingDb)
            {
                var orders = context.Query<Order, OrderTotals, Address, Item, Order>(query, (o, ot, a, i) =>
                {
                    //This loops through each record and does the work of creating the shipworks order objects


                    Dictionary<string, Item> items;
                    Item item;
                    //If we haven't created the items list
                    if (!itemLookup.TryGetValue(o.OrderNumber, out items))
                    {
                        //Add the new item list to the lookup -- Since the order object needs an array we will add these at the very end. Otherwise we would have to convert between dictionaries and lists on every record.(more expensive)
                        items = new Dictionary<string, Item>();
                        items.Add(i.ItemID, i);
                        itemLookup.Add(o.OrderNumber, items);
                    }

                    //If we haven't created the item in the existing list
                    else if (!items.TryGetValue(i.ItemID, out item))
                    {
                        items.Add(i.ItemID, i);
                    }

                    Order order;

                    //If we haven't created the order
                    if (!orderLookup.TryGetValue(o.OrderNumber, out order))
                    {
                        //Add Order Totals
                        var totals = new OrderTotal[]
                            {
                                    new OrderTotal()
                                    {
                                        impact = "none",
                                        @class = "subtotal",
                                        name = "Sub-Total:",
                                        id = 1,
                                        Value = ot.subtotal
                                    },
                                    new OrderTotal()
                                    {
                                        impact = "add",
                                        @class = "shipping",
                                        name = o.ShippingMethod + ":",
                                        id = 2,
                                        Value =ot.shipping
                                    },
                                    new OrderTotal()
                                    {
                                        impact = "none",
                                        @class = "total",
                                        name = "Total:",
                                        id = 3,
                                        Value = ot.total
                                    }
                            };
                        o.Totals = totals;

                        //Add Addresses
                        o.ShippingAddress = a;
                        o.BillingAddress = a;

                        //Add the order to the lookup
                        orderLookup.Add(o.OrderNumber, order = o);
                    }

                    return order;
                }, splitOn: "OrderNumber,Subtotal,FullName,ItemID",
                    param: new
                    {
                        LastModified = sqlStartTime
                    });
            }

            Order ord;
            Dictionary<string, Item> il;

            // Loop through the orders and do everything we couldn't do easily in dapper

            foreach (var order in orderLookup.ToList())
            {
                // - Add items to the orders
                orderLookup.TryGetValue(order.Key, out ord);
                itemLookup.TryGetValue(order.Key, out il);
                ord.Items = il.Values.ToArray();

                // - Convert Dates to UTC
                ord.OrderDate = TimeZoneInfo.ConvertTimeToUtc(ord.OrderDate, centralTimeZone);
                ord.LastModified = TimeZoneInfo.ConvertTimeToUtc(ord.LastModified, centralTimeZone);
            }

            //finally add the results to the class "item" object and return the xml
            Item = new ShipWorksOrders() { Order = orderLookup.Values.ToArray() };

            //Update the order status to printed as soon as this is complete to prevent the order from being shipped again.
            if (orderLookup.Count > 0) { UpdateBatchToPrinted(Array.ConvertAll(orderLookup.Keys.ToArray(), i => (int)i)); }

            return ToXDoc();
        }
        #endregion

        #region Api Calls
        public XDocument UpdateStatus(int orderID, string orderStatus)
        {

            var req = new ChangeOrderStatusRequest();
            req.OrderID = orderID;
            req.OrderStatus = (OrderStatusType)Enum.Parse(typeof(OrderStatusType), orderStatus, true);

            var res = api.ChangeOrderStatus(req);
            bool success = true;
            Item = success;
            return ToXDoc();
        }
        public XDocument UpdateShipment(int orderID, string tracking, string carrier)
        {
            // TODO It only passes one tracking number at a time so we need to pull the order first to see if we have it... maybe...

            // TODO Do we need to exclude Return Shipments?

            /// DOCUMENTATION 
            /// 1- We won't store anything except the tracking number and carrier if we have a match in exigo.
            /// 2- ShippedDates etc... are disregarded we will set the shipdate based on when the status change was sent to exigo.

            var req = new UpdateOrderRequest();
            req.OrderID = orderID;
            req.TrackingNumber1 = tracking; // TODO If there are multiple we need to do somthing different here... TEST
            // TODO What if the tracking number is voided? do we delete it? revert the status? etc.... questions...
            // TODO test shipdate in exigo... need to make sure it gets populated on the order status change (Could impact taxes if not populated....)
            // try to map the carrier if not, just don't update it
            OrderShipCarrier parsedCarrier;
            int testnum;
            if (Enum.TryParse(carrier, true, out parsedCarrier) && !int.TryParse(carrier, out testnum)) //<-- make sure a number isn't passed in or the enum parse will always grab the first item.
            {
                req.WebCarrierID1 = parsedCarrier;
            }
            else
            {
                req.WebCarrierID1 = null;
            }

            var res = api.UpdateOrder(req);
            bool success = true;
            Item = success;
            return ToXDoc();
        }
        private void UpdateBatchToPrinted(int[] orderIDs)
        {

            var req = new ChangeOrderStatusBatchRequest();
            List<OrderBatchDetailRequest> details = new List<OrderBatchDetailRequest>();
            foreach (var o in orderIDs)
            {
                details.Add(new OrderBatchDetailRequest() { OrderID = o });
            }
            req.OrderStatus = OrderStatusType.Printed;
            req.Details = details.ToArray();

            var res = api.ChangeOrderStatusBatch(req);
            var test = "test";
        }
        public XDocument GetOrdersResponseFromApi(DateTime startDate, int maxCount)
        {

            //Grab the warehouse and shipmethods so we can lookup values list shipmethod name as needed.
            var warehouseConfigs = new WarehouseConfigs(api);

            List<OrderResponse> allorders = GetAPIOrders(startDate);

            //Sort the list so we give the oldest ones first.
            allorders.OrderBy(o => o.ModifiedDate);


            var shipWorksOrders = new List<Order>();

            //Grab only the amount requested
            foreach (var order in allorders.Take(maxCount))
            {

                //Get Shipping Method Description
                var shippingMethod = warehouseConfigs.GetShipMethodDetails(order.WarehouseID, order.ShipMethodID).Description;

                //Map all the order details to the shipworks item model
                int lineCounter = 0;
                var items = new List<Item>();
                foreach (var OrderDetailResponse in order.Details)
                {

                    lineCounter++;
                    var item = new Item()
                    {
                        ItemID = lineCounter.ToString(),
                        ProductID = OrderDetailResponse.ItemCode,
                        Code = OrderDetailResponse.ItemCode,
                        Name = OrderDetailResponse.Description,
                        Quantity = OrderDetailResponse.Quantity,
                        UnitPrice = OrderDetailResponse.PriceEach,
                        Weight = OrderDetailResponse.Weight
                        //Attributes  <-- Not planning on adding all the extra item detail... so skipping this for now.
                    };

                    items.Add(item);
                }

                //Add the payments if we have any...
                var payments = new List<OrderPaymentDetail>();
                foreach (var p in order.Payments)
                {
                    var payment = new OrderPaymentDetail()
                    {
                        name = p.PaymentType.ToString(),
                        value = p.Amount.ToString()
                    };
                    payments.Add(payment);
                }

                //
                var obj = new Order()
                {
                    OrderNumber = order.OrderID,
                    OrderDate = TimeZoneInfo.ConvertTimeToUtc(order.OrderDate, centralTimeZone),
                    LastModified = TimeZoneInfo.ConvertTimeToUtc(order.ModifiedDate, centralTimeZone),
                    LastModifiedSpecified = true, // <-- Last Modified wasn't showing up in the XML Serializer... not sure why, this isn't listed in their documentation but it works now...
                    ShippingMethod = shippingMethod,
                    StatusCode = "Printed", //order.OrderStatus.ToString(), // <-- Force to printed as that is what we will update it to
                    CustomerID = order.CustomerID.ToString(),
                    //Notes <--Skipping Notes for now 
                    ShippingAddress = new Address()
                    {
                        //FirstName = order.FirstName, <--- Shipping Address apparently doesn't support first and last name per the XSD validation
                        //LastName = order.LastName,
                        FullName = order.FirstName + " " + order.LastName,
                        Company = order.Company,
                        Street1 = order.Address1,
                        Street2 = order.Address2,
                        Street3 = order.Address3,
                        City = order.City,
                        State = order.State,
                        PostalCode = order.Zip,
                        Country = order.Country,
                        Phone = order.Phone,
                        Email = order.Email

                    },
                    BillingAddress = new Address() //TODO -- Follow up on what this is used for in shipworks and why it's required... should this be the customer address????
                    {
                        //FirstName = order.FirstName, <--- Billing Address apparently doesn't support first and last name per the XSD validation
                        //LastName = order.LastName,
                        FullName = order.FirstName + " " + order.LastName,
                        Company = order.Company,
                        Street1 = order.Address1,
                        Street2 = order.Address2,
                        Street3 = order.Address3,
                        City = order.City,
                        State = order.State,
                        PostalCode = order.Zip,
                        Country = order.Country,
                        Phone = order.Phone,
                        Email = order.Email

                    },
                    Payment = new OrderPayment() { Items = payments.ToArray() },
                    Items = items.ToArray(),
                    Totals = new OrderTotal[]
                    {
                        new OrderTotal()
                        {
                            impact = "none",
                            @class = "subtotal",
                            name = "Sub-Total:",
                            id = 1,
                            Value = order.SubTotal
                        },
                        new OrderTotal()
                        {
                            impact = "add",
                            @class = "shipping",
                            name = shippingMethod + ":",
                            id = 2,
                            Value = order.ShippingTotal
                        },
                        new OrderTotal()
                        {
                            impact = "add",
                            @class = "tax",
                            name = "Taxes:",
                            id = 3,
                            Value = order.TaxTotal
                        },
                        new OrderTotal()
                        {
                            impact = "none",
                            @class = "total",
                            name = shippingMethod + ":",
                            id = 4,
                            Value = order.Total
                        },
                    }
                };
                shipWorksOrders.Add(obj);
            }

            Item = new ShipWorksOrders() { Order = shipWorksOrders.ToArray() };

            //Update the order status to printed as soon as this is complete to prevent the order from being shipped again.
            if (shipWorksOrders.Count > 0) { UpdateBatchToPrinted(Array.ConvertAll(shipWorksOrders.Select(o => o.OrderNumber).ToArray(), i => (int)i)); }

            return ToXDoc();
        }
        private List<OrderResponse> GetAPIOrders(DateTime greaterThanModifiedDate)
        {

            var req = new GetOrdersRequest();
            DateTime startDateTime = TimeZoneInfo.ConvertTimeFromUtc(greaterThanModifiedDate, centralTimeZone);

            //shipworks will start at 0 BC which sql doesn't like... so we will catch this and set it to 1/1/1900
            var earliest = new DateTime(1900, 1, 1, 0, 0, 0);
            if (DateTime.Compare(startDateTime, earliest) > 0)
            {
                req.GreaterThanModifiedDate = startDateTime;
            }
            else
            {
                req.GreaterThanModifiedDate = earliest;
            }

            req.BatchSize = 1000000;
            req.OrderStatus = OrderStatusType.Accepted; // <-- we will only count accepted orders. as soon as get orders is called that bactch will be updated to printed.

            //We need to pull in everything after the modified date regardless 
            //of what other order filters are at this point as everything in the 
            //API orders by orderid and that is the order that they will be returned by the API.

            var orders = api.GetOrders(req);
            var allorders = orders.Orders.ToList();
            foreach (var order in allorders.ToList())
            {
                //Filter out any orders we don't care about.

                //Filter Out Return Orders
                if (order.OrderType == OrderType.ReturnOrder)
                {
                    allorders.Remove(order);
                    continue;
                }

            }
            return allorders;
        }
        public XDocument GetCountResponseFromApi(DateTime greaterThanModifiedDate)
        {

            List<OrderResponse> allorders = GetAPIOrders(greaterThanModifiedDate);

            //Update the response variable
            Item = allorders.Count();
            return ToXDoc();
        }
        public class WarehouseConfigs
        {

            public Dictionary<WarehouseResponse, ShipMethodResponse[]> warehouses = new Dictionary<WarehouseResponse, ShipMethodResponse[]>();


            //Grab all the warehouses and shipmethods and load them to an internal set of lists so we don't need to call it over and over again when we get orders.
            public WarehouseConfigs(ExigoApi api)
            {

                var req = new GetWarehousesRequest();
                var res = api.GetWarehouses(req).Warehouses;

                foreach (var warehouse in res)
                {
                    var shipMethodReq = new GetShipMethodsRequest();
                    shipMethodReq.WarehouseID = warehouse.WarehouseID;
                    var shipMethods = api.GetShipMethods(shipMethodReq).ShipMethods;
                    warehouses.Add(warehouse, shipMethods);
                }
            }

            public ShipMethodResponse GetShipMethodDetails(int warehouseID, int shipMethodID)
            {
                try
                {
                    return warehouses.Single(w => w.Key.WarehouseID == warehouseID).Value.Single(s => s.ShipMethodID == shipMethodID);
                }
                catch
                {
                    throw new Exception("Warehouse / Shipmethod on order is invalid, pleaes correct the order.");
                }
            }
        }
        #endregion
    }
    public class OrderTotals
    {
        ///Added an extra class to store the order total stuff in an object 
        ///that we will use when building the order total array in the order 
        ///object, without this we would have to do additional joins to repeat 
        ///the order row multiple times to play nice with dapper.

        public decimal subtotal;
        public decimal total;
        public decimal shipping;
    }


}